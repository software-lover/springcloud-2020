1、Eureka、Consul，Zookeeper
---------------------------------------------------------------------------------------------------------------
| 组件名称    |    语言     |     CAP     |      服务健康检查     |      对外暴露接口      |       Spring Cloud集成 |
|---------------------------------------|---------------------------------------------------------------------|
| Eureka     |    Java    |      AP     |       可配置支持      |         HTTP         |            已集成       |
| Consul     |    Go      |      CP     |        支持          |       HTTP/DNS       |            已集成       |
| Zookeeper  |    Java    |      CP     |        支持          |         客户端        |            已集成       |
---------------------------------------------------------------------------------------------------------------
C：Consistency（强一致性）
A：Availability（可用性）
P：Partition tolerance（分区容错性）

CAP理论关注的粒度是数据，而不是整体系统设计的策略

AP：Eureka，CouchDB，Cassandra，DynamoDB
CP：Zookeeper，Consul，MongoDB，HBase，Redis
CA：RDBMS

对于微服务架构来说，P（分区容错性）是一定要保证的，所有对于分布式系统来说，不是AP就是CP；最多只能同时较好的满足两个。

CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求：
因此，根据CAP原理，将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类：

CA —— 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大
CP —— 满足一致性，分区容错性的系统，通常性能不是特别高
AP —— 满足可用性，分区容错性的系统，通常可能对一致性要求低一些


consul 使用方式
1、直接进入到解压后的 consul 目录，打开命令提示符界面输入： consul --version  命令可以查看版本号
2、执行 consul agent -dev  即可启动
3、启动后浏览器输入 http://localhost:8500/     即可打开管理界面


========================================================================================================================


2、Ribbon
RoundRobinRule：轮询
RandomRule：随机
RetryRule：先按照RoundRobinRule的策略获取服务，如果获取服务失败，则在指定时间内会进行重试，获取可用的服务
TimeRule：对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择
BestAvailableRule：会先过滤掉由于多次访问故障而处于熔断跳闸状态的服务，然后选择一个并发量最小的服务
AvailabilityFilteringRule：先过滤掉故障实例，再选择并发较小的实例
ZoneAvoidanceRule：默认规则是符合判断Service所在区域的性能和Service的可用性选择服务器

轮询算法： rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置的下标。每次服务重启后rest接口计数从1开始


========================================================================================================================
3、Feign与OpenFeign
没有Feign的话，之前是使用RestTemplate去调用微服务，使用Feign可以基于接口的方式去调用微服务


========================================================================================================================


4、Hystrix
服务降级（fallback）："服务器忙，请稍尝试"，不让客户端等待并立刻返回一个友好提示，fallback
    程序运行异常
    超时
    服务熔断触发服务降级
    线程池/信号量打满也会导致服务降级
服务熔断（break）：类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示
服务限流（flowlimit）：秒杀高并发等操作，严禁一蜂窝的过来拥挤，大家排队，一秒钟N个，有序进行

服务降级是直接每次都返回降级的兜底服务，而服务熔断是当服务不可用时，后续会通过监控去检测服务的可用性，再次可用时，则调用正常的服务逻辑
————服务正常时，关闭熔断；服务异常时，开启熔断；之后进入熔断半开状态，尝试是否可以恢复服务，允许小部分请求进入，看是否可以正常调用服务

熔断打开：请求不再进行调用当前服务，转而调用降级服务，内部设置时钟一般为MTTR（平均故障处理时间），当打开时长达到所设时钟则进入半熔断状态
熔断关闭：熔断关闭则不会对服务进行熔断
熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断，恢复调用链路

断路器开启或者关闭的条件：
    ①当满足一定的阈值的时候（默认10秒内超过20个请求次数）
    ②当失败率达到阈值的时候（默认10秒内超过50%的请求失败）
    ③到大以上阈值，断路器将会开启
    ④当开启的时候，所有的请求都不会进行转发
    ⑤一段时间之后（默认是5秒），这个时候断路器会进入半开状态，会让其中一个请求进行转发；如果成功，断路器将会关闭；若失败，继续变为开启。重复④和⑤

fallback服务降级既可以在服务器端进行，也可以在客户端进行，但是一般情况下是在客户端进行的


========================================================================================================================


5、Gateway

核心概念：路由、断言、过滤器

出现的原因：Netflix 的 zuul 停更，且 zuul 一直跳票，迟迟未出，所以 SpringCloud 就自己开发了一个 SpringCloud Gateway

SpringCloud Gateway 具有如下特性：
    基于 Spring Framework5，Project Reactor 和 SpringBoot2.0 进行构建
    动态路由：能够匹配任何请求属性
    可以对路由指定 Predicate（断言）和 Filter（过滤器）
    集成 Hystrix 的断路器功能
    集成 Spring Cloud 服务发现功能
    易于编写的 Predicate（断言）和 Filter（过滤器）
    请求限流功能
    支持路由重写

Spring Cloud Gateway 采用 WebFlux 框架的 Reactor 模型，底层使用的是 Netty 高性能网络通信框架

Spring Cloud Gateway 与 Zuul 的区别
    在 SpringCloud Finchley 正式版之前，Spring Cloud 推荐的网关是 Netflix 提供的 Zuul
 Zuul 1.x，是一个基于阻塞 I/O 的 API Gateway
 Zuul 1.x 基于 Servlet 2.5 使用阻塞架构，它不支持任何长连接（如 WebSocket），Zuul 的设计模式和 Nginx 较像，每次 I/O 操作都是从工作线程
    中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是 Nginx 用 C++ 实现，Zuul 用 Java 实现，而 JVM 本身会有第一次加载就较慢的情况，
    使得 Zuul 的性能相对较差
 Zuul 2.x 理念更先进，想基于 Netty 非阻塞和支持长连接，但 Spring Cloud 目前还未整合。Zuul 2.x 的性能较 Zuul 1.x 有较大提升。在性能方面，
    根据官方提供的基准测试，Spring Cloud Gateway 的 RPS(每秒请求数)是 Zuul 的 1.6 倍
 Spring Cloud Gateway 建立在 Spring Framework 5，Project Reactor 和 Spring Boot 2 之上，使用非阻塞API
 Spring Cloud Gateway 还支持 WebSocket，并且与 Spring 紧密集成，拥有更好的开发体验



========================================================================================================================


6、Config

假如运维人员在GitHub上面改了配置，那么3344配置中心是可以及时读取最新内容的，但是客户端3355是从3344配置中心读取的，所有3355不会及时刷新，

为了解决这个问题：
需要在客户端bootstrap.yml加上监控端点配置；
在Controller里面加上@RefreshScope注解；
需要post请求刷新3355，curl -X POST "http://localhost:3355/actuator/refresh"

但是假如机器很多，每台机器都执行 POST 去刷新？ 第二、有些机器不需要刷新，怎么办？
此时引入 BUS 消息总线实现配置的动态刷新


========================================================================================================================


7、Bus

支持两种消息代理：RabbitMQ 和 Kafka

具有两种配置刷新的方式（会广播刷新所有客户端）：
利用消息总线触发一个配置中心服务器端 ConfigServer 的 /bus/refresh 端点，从而广播刷新所有客户端配置（使用这种触发服务器端的方式更合适）
利用消息总线触发一个配置客户端 /bus/refresh，从而广播刷新所有客户端配置

触发配置中心服务器端的刷新：curl -X POST "http://localhost:3344/actuator/bus-refresh"

定点通知：指定具体某个实例生效而不是全部。如只通知3355 不通知3366
公式：curl -X POST "http://localhost:配置中心端口号/actuator/bus-refresh/{destination}"
如：curl -X POST "http://localhost:配置中心端口号/actuator/bus-refresh/config-client:3355"
其中 destination 对应 spring.application.name 里面配置的服务名称机器实例对应端口号
即/bus/refresh请求不再发送到具体的服务实例上，而是发给config server，通过 destination 参数类指定需要更新配置的服务实例



========================================================================================================================

8、Stream

屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型

一个消息生产者发送的消息，两个消息消费者都可以消费，存在重复消费的问题：使用 Stream 的消息分组来解决

不同组是可以全面消费的（重复消费）
    可以在rabbitmq管控平台 Exchanges tab 页签里面看到：
    Queue studyExchange.anonymous._OxKHt0EShe-ZHUCAoeG6A  表示 8802消费者
    Queue studyExchange.anonymous.ks75xdsQTtC2_J-oy6XfDQ  表示 8803消费者
    默认分组是不同的，组流水号不一样，表示两个消费者处于不同的组，导致重复消费
    这个流水号是自动生成的，可以在配置文件里面自定义

同一组内会发送竞争关系，只有其中一个可以消费
    在配置文件里面，自定义配置分为同一个组，解决重复消费的问题

配置了 group 分组之后，默认就实现了消息持久化，不会导致数据丢失



========================================================================================================================



9、Sleuth 分布式请求链路监控

zipkin 下载地址：http://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/
运行 zipkin：java -jar zipkin-server-2.12.9-exec.jar
浏览器打开： http://127.0.0.1:9411/zipkin/

名词：
Trace：类似于树结构的 Span 集合，表示一条调用链路，存在唯一标识
Span：表示调用链路来源，通俗的理解 span 就是一次请求消息
多个 Span 组成一个 Trace



========================================================================================================================



10、Nacos（替代 eureka 做服务注册与发现，替代 config 做配置中心）

下载地址(下载1.1.4版本即可)：https://github.com/alibaba/nacos/releases/tag/1.1.4
解压后，进入 bin 目录，执行 startup.cmd 即可，浏览器输入： http://127.0.0.1:8848/nacos/index.html 即可，默认账号密码都是 nacos

Nacos支持 AP 和 CP，可以进行切换： curl -X PUT '$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&value=CP'

在 Nacos Spring Cloud 中，dataId 的完整格式如下：
    ${prefix}-${spring.profile.active}.${file-extension}

    prefix 默认为 spring.application.name，也可以通过配置项 spring.cloud.nacos.config.prefix 来配置
    spring.profile.active 即为当前环境的 profile，为空时，对应的连接符 - 也将不存在，dataId的拼接格式变成 ${prefix}.${file-extension}
    file-extension 为配置内的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置，目前只支持 properties 和 yaml 类型
参考官方文档：https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html

默认情况下：
Namespace=public, Group=DEFAULT_GROUP, 默认 Cluster 是 DEFAULT

Nacos 默认的命名空间是 public，Namespace 主要用来实现隔离
比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个 Namespace，不同的 Namespace 之间是隔离的

Group 默认是 DEFAULT_GROUP，Group 可以把不同的微服务划分到同一个分组里面去

Service 就是微服务，一个 Service 可以包含多个 Cluster（集群），Nacos 默认 Cluster 是 DEFAULT，Cluster 是对指定微服务的一个虚拟划分。
比方说为了容灾，将 service 微服务分别部署在了杭州机房和广州机房，这时就可以给杭州机房的 Service 微服务起一个集群名称（HZ），给广州机房的
Service 微服务起一个集群名称（GZ），还可以尽量让同一个机房的微服务互相调用，以提升性能

最后是 Instance，就是微服务的实例

Nacos 集群模式：
https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html
https://nacos.io/zh-cn/docs/deployment.html
--------------------------------
            nacos               |
            /   \               |
      nginx01    nginx02        |
                                |
 nacos01     nacos02    nacos03 |
      \         |        /         |
         高可用mysql集群          |
---------------------------------

nacos 默认使用了嵌入式的数据库 Derby，这样假如部署集群的话，那么每个实例都会有自带的数据库 Derby，无法保证数据一致性；
所以要部署集群模式的 nacos 的话，需要使用一个集中式的数据库，目前 nacos 只支持 MySQL，且数据库也需要高可用，需要一主一备

1.安装数据库，版本要求：5.6.5+
2.初始化mysql数据库，数据库初始化文件：nacos-mysql.sql
3.修改conf/application.properties文件，增加支持mysql数据源配置（目前只支持mysql），添加mysql数据源的url、用户名和密码，如下
spring.datasource.platform=mysql
db.num=1
db.url.0=jdbc:mysql://11.162.196.16:3306/nacos_devtest?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true
db.user=nacos_devtest
db.password=youdontknow

在 Linux 安装好 nacos 后
1. 调整 conf 目录下面的 application.properties 配置文件，增加 MySQL数据源配置
2. 调整 cluster.conf 配置集群信息，注释掉默认的，添加自己机器 ip 和自定义的端口号，假如是集群的话，那么集群 ip 都一样，端口号设置不一样
3. 调整 startup.sh 文件，使其支持通过参数启动多个实例，如 ./startup.sh -p 3333  启动端口号为 3333 的实例
4. 调整 nginx.conf 配置文件， 配置好 upstream 及其代理信息
5. 启动 nginx（./nginx -c /srv/www/install/nginx-1.8.0/conf/nginx.conf  在 /usr/local/nginx/sbin 目录），启动三台 nacos
启动后浏览器打开：http://nginx-ip:nginx-port/nacos/#/  即可

之后可以把服务注册地址切换为 nginx-ip:nginx-port 即可把服务注册到集群

========================================================================================================================


========================================================================================================================


========================================================================================================================



========================================================================================================================



========================================================================================================================



========================================================================================================================



========================================================================================================================



========================================================================================================================



========================================================================================================================



========================================================================================================================



========================================================================================================================



========================================================================================================================




